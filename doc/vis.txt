Вопрос по трансляции интерфейса и кодировке:
 - файлы перевода текстов кнопок, окон и т.п. должны быть в кодировке utf-8;
 - ;

Собственно, какая цель:
 - разработать гибкую и мощную систему для построения диалоговых визуальных приложений под NIX на основе ncurses;
   за основу взята идеология TurboVision.
 - на основе диалоговой системы разработать текстовый редактор, максимально приближенный к IDE.
 - основная цель - сделать мощный IDE не слабее Qt-Creator на базовом уровне редактирования и отладки,
   работающего в консольном режиме.
 - преимущества консольной IDE очевидны - доступность.
   Я пытался наладить контакт с такими *NIX-редакторами, как vim, emacs и многими другими, которые вообще где-либо
   упоминаются в интернете и столкнулся с отсутствием нормальной среды разработки в консольном режиме.
   Но любые редакторы, отличные от vim/emacs не тянут и половины моих пожеланий, а сами vim/emacs требуют
   углубленного изучения и "постижения" их тайных знаний, "принятия их религии". Иначе назвать нельзя, ибо чтобы в
   них работать с комфортом, нужно:
    1. перевернуть мозги с ног на голову, потому что у Vim своя идеология;
    2. изрядно побороться, чтобы сделать из того же vim некое подобие IDE.
   Кто-то скажет: "Vim? Да там всё просто!" Верно - всё просто, когда уже всё знаешь, но прежде чем узнаешь, придётся
   истоптать весь инет вдоль и поперёк.
Итого: Такого текстового редактора просто нет.
Я бы с большим удовольствием использовал даже просто текстовый редактор, который:
    - Не имел бы дурацких режимов типа insert/command/visual и т.п., как, например, в vim. Считаю, что редактор
      должен быть редактором, а не командным процессором.
    - Умел бы вести дерево проектов; в качестве исходных данных - поддерево файловой системы.
    - Делать навигацию по файловой системе вместо/наряду с деревом проектов.
    - Иметь синтаксическую раскраску исходного кода;
    - Разумеется, вести историю редактирования;
    - Открывать несколько файлов во вкладках либо списком - на выбор;
    - Переключаться между этими файлами по Ctrl+Tab/Ctrl+Shift+Tab (да пусть даже по другой комбинации);
    - Нумеровать строки;
    - Позволять выделять, копировать, вырезать и вставлять текст так же, как все нормальные редакторы, как gedit;
    - Шифтить выделенные блоки текста вперёд/назад;
    - Делать поиск/замену по строке/регулярке в пределах одного файла с учётом регистра и без.
    - Делать поиск по множеству файлов также по строке/regexp с учётом case и без.
    - Желательно имел прикрученную распознавалку (intelli-sence) на основе clang-компилятора.


(*) Сущности на верхнем уровне:
    = Сущность "Приложение". Умеет:
        - парсить командную строку.
        - читать конфиг-файлы.
        - запускать виртуальный метод пользователя с прочитанным конфигом/параметрами.
      Все настройки и конфиг файлы считываются в единую древовидную структуру "Свойства" - Properties.
      В корень дерева свойств можно прочитать любое количество конфигов. Имя корневого элемента - ?имя конфиг файла?.
      Любое поддерево свойств можно сохранить в отдельный конфиг.
      Так будет обеспечиваться:
       - единое конфигурирование цветов;
       - локализация интерфейса на нужный язык;
       - возможность привязать значения визуальных элементов к свойствам; соответственно - их сохранение/загрузка.
       - просто удобство.

    = Очередь событий; события бывают:
        * системное:
            - от мыши.
            - от клавиатуры.
            - ?от таймера?
              От таймера возможно будет полезным, когда какой-либо элемент "заказывает" себе таймер с
              определённым интервалом.
        = onResize
        = onMove
        * сообщение - одна из реакций какого-либо элемента на событие. Например, отправка сообщения связанному элементу.
          Скажем, от элемента "Текстовый редактор" элементу "ScrollBar" о том, что курсор сместился вверх, и
          возможно нужно перестроить внешний вид ScrollBar'а.
          Пока ещё вопрос, как это сделать грамотно - возможно выделить ряд стандартных команд, например:
              msgUp
              msgDown
              msgLeft
              msgRight
              msgChange
              msgUpdate
          + 1-2 int-овых поля общего назначения.
          Соответственно, сообщения могут быть адресными (1 или несколько элементов) либо broadcast.
          Но тут возникают вопросы:
           1) "кто-кому" будет иметь право пересылать сообщения? Скорее всего, только в рамках окна.
           2) кто будет иметь право рассылать broadcast сообщения? Desktop only?
        => Возможно, сообщения не будут передаваться через очередь. Но пока такой способ представляется более
           простым и понятным.
           ?Сделать очередь сообщений?

    = Визуальные элементы:
        * Виды элементов:
            - Модальная группа (ModalGroup).
              У модальной группы может быть 0 или несколько стандартных дочерних групп.
              Desktop == ModalGroup.
            - Стандартная группа (Group) - является дочерней по отношению к модальной.
              У стандартной группы может быть 0 или несколько дочерних элементов.
              Уничтожается вместе с модальной группой.
              Window == Group.
            - Группа-документ (DocumentGroup) - то же, что и Group, только отображается в визуальных пределах
              модальной группы.
            - Элемент (Item).
              У элементов может быть 0 или несколько дочерних элементов.

                          ModalGroup
                               v
                       +--------------+-------+
                       v              v       v
                     Group          Group   Group
                       v              v       v
                    +--------+----+  ...     ...
                    v        v    v
                   Item     Item Item
                    v        v    v
               +----+----+  ...  ...
               v    v    v
              Item Item Item
               v    v    v
              ...  ...  ...

           Моменты:
            - Для ModalGroups заводится стек, на вершине которого лежит текущая модальная группа.
              При старте визуальной системы на вершине стека будет лежать Desktop.
              Таким образом модальное окно может породить ещё одно модальное, либо несколько немодальных.
            - Дочерние НЕмодальные группы всегда находятся поверх родительской модальной.
            - Не возможно переключится на другие окна (модальные/немодальные) других модальных предков.
           Таким образом окна никогда не смогут быть под Desktop'ом, а события всегда будет только в рамках
           модального окна, лежащего на вершине стека, и его дочерних окон.

        * Реакция визуальных элементов на события - команда + сообщение.
          Команду удобно послать от элемента к владеющему элементом окну. Для этого не нужно указывать целевое окно,
          команда будет в виде return-value обработчика специальных событий типа OnClick и т.п. Cистема сама разберётся
          кому её передать.
          Команды удобны для кнопок - cmOk, cmCancel, cmClose, cmNothing.

        * Как элемент будет перерисовываться.
          Рисовать в единый специальный буфер через подсистему визуализации, которая будет:
           - автоматически перерисовывать всё, что нужно, дёргая виртуальный метод Draw() только у тех элементов
             которые нужно перерисовать.
           - для каждого элемента рисовать только то, что у него видно в данный момент.
           - после перерисовки обновлять вид "физического" экрана из специального буфера. Как - вопрос отдельный.
             Можно оптимизировать (что более логично для графических систем), либо просто полностью вывести всё на
             экран, что в консолном режиме вполне достаточно.
          Вот это, ИМХО, хотя и трудоёмкий, но верный путь, т.к. вообще говоря именно система должна определять
          стратегию того, как, что и когда рисовать.
            = Стратегия перерисовки:
                1) Когда перерисовка:
                    = Когда элемент изменил положение/размеры:
                        - если элемент переместился.
                        - если элемент изменил размеры.
                       Тогда:
                        - рисуется сам элемент на новом месте/с новыми размерами;
                        - рекурсивно рисуются все его дочерние;
                        - вычисляется список элементов View, которые лежали под той областью,
                          которая стала не используема;
                        - всем этим элементам рассылается Reraw();
                        - делается Screen::Refresh().
                     = Когда изменился фокус элемента (System::State::SetFocus(view) должен сначала сделать неактивным
                       прежнего владельца фокуса, ему Redraw(), поставить фокус на новый и ему Redraw()).
                     = Когда пришло сообщение EventRedraw - дёргается View::OnDraw() элемента и его дочерних.
                       Сам пользователь такое событие не должен иметь возможности запостить "руками" -
                       только с помощью метода View::Redraw().
                       Для чего вообще такое сообщение?
                       Когда изменилось некое состояние элемента.
                       Например: задача копирования файла "в фоне". Для этого окно, в котором отображается статус
                       копирования, "заказало" для себя таймер. Событие таймера приходит в это окно, по которому
                       копируется порция данных. После копирования данных вызывается Gauge::SetPercentage(). Очевидно,
                       что логичным будет изменение внешнего вида элемента.
                     = Если элемент уничтожили - его нужно стереть.

        * Визуальное якорение к родительскому элементу (anchors):
            anCenterX       - центровать по горизонтали (исключает anLeft + anRight)
            anCenterY       - центровать по вертикали (исключает anTop + anBottom)
            anLeft          - зафиксировать относительно левой границы (исключает anCenterX)
            anRight         - зафиксировать относительно правой границы (исключает anCenterX)
            anTop           - зафиксировать относительно верхней границы (исключает anCenterY)
            anBottom        - зафиксировать относительно нижней границы (исключает anCenterY)
            anExposeLeft    - расширение влево
            anExposeRight   - расширение вправо
            anExposeTop     - расширение вверх
            anExposeBottom  - расширение вниз
            anExposeAll     - расширение во все стороны (эквивалент четырех вышеперечисленных)

        * Атрибуты:
            atFocusable - может ли элемент принять фокус. Например StaticText не сможет его принимать.
                          Возможно также изменение этого состояния через System::Attr::SetFocusable(view).
                          Например, если нужно в(ы)ключить какой-то блок элементов в зависимости от установленного/
                          сброшенного Checkbox'а.
            atMovable   - может ли элемент быть перемещён относительно своего предка.
            atSizeable  - может ли элемент изменять размеры.
          Последние два атрибута будут хранится в View::protected-переменной, задаваться внутри элементов
          константно.
          Все атрибуты будут доступны только на чтение внешнему миру через
            inline virtual View::GetAttr() = 0.

        * Состояния у элементов:
            stVisible   - видимый.
                System::State::SetVisible(view, bool)

            stFocused   - под фокусом.
                System::State::SetFocus(view, bool) - устанавливает фокус на родительскую группу, на сам элемент и
                далее по иерархии дочерних элементов данного элемента.
                View* System::State::GetFocus();
                bool View::IsFocused();
                Изменение фокуса - не простой процесс, т.к. он влияет на две вещи:
                 - изменение z-order-а групп;
                 - "вручение" состояние stFocused тому элементу, на который был установлен фокус и "забирание" этого
                   состояния у прежнего элемента;
                 - соответствующая перерисовка.

            stResizing  - в состоянии изменения размера.
                System::State::SetResizing(view, bool)
                bool View::IsResizing();

            stMoving    - в состоянии перемещения.
                System::State::SetMoving(view, bool)
                bool View::IsMoving();

        * Для кнопки - признак активности
            Button::Button(..., bool is_active = false)
            bool Button::IsActive() { return is_active_; }

    = Как система будет искать, кому передать событие:
        * От клавиатуры:
            - Видимо так: Current Modal Field -> Active Field -> Active Element -> Focused Element.
          Два случая:
           1) Если Current Modal Field == Desktop, тогда цепочка такая же, как выше;
           2) Если Current Modal Field == ModalWindow, то Active Field в этой цепочке не будет.
        * От мыши - почти также:
            - Current Modal Field -> Поиск окна, в которое ткнули -> Поиск элемента внутри окна по z-tree.

---
Как должен быть устроен "редактор":
TextBuffer - объект-контейнер
    - к одному буферу может быть привязано  несколько TextEdit'ов.
    - отсылает сообщения "Changed" привязанным TextEdit'ам с координатами (строками, областью) того, что изменилось.
    - предоставляет интерфйес для:
        * изменения текста для TextEdit'а
        * получения текста для TextEdit'а
TextEdit - визуальный элемент
    - TextEdit без буфера ничего делать не будет.
    - изменяет TextBuffer
    - берёт текст из TextBuffer
    - выводит изменения в TextBuffer'е через TextEditFilter
TextEditFilter - специальный объект-фильтр для раскраски текста из буфера в зависимости от языка программирования.

